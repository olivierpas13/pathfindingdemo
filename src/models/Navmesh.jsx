/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from "@react-three/drei";
import navmeshScene from "../assets/roadMesh.glb";
import { Pathfinding, PathfindingHelper } from "three-pathfinding";
import { vec3 } from "@react-three/rapier";
import { useFrame } from "@react-three/fiber";


const Navmesh = ({ humanPosition, setHumanPosition, setImpulse, ...props }) => {

  const SPEED = 5;
  const ZONE = "road";
  let groupID;
  let navpath;
  let target;

  const { nodes, materials, ...all } = useGLTF(navmeshScene);
  const scenePos = (all.scene.position)
  // const humanPosition = vec3({
  //   x: humanPosition[0],
  //   y: humanPosition[1],
  //   z: humanPosition[2],
  // }) ;
  const pathfinding = new Pathfinding();
  const pathfindinghelper = new PathfindingHelper();

  const navmesh = nodes.Navmesh;

  pathfinding.setZoneData(ZONE, Pathfinding.createZone(navmesh.geometry));
  groupID = pathfinding.getGroup(ZONE, humanPosition);
  const nmID = pathfinding.getGroup(ZONE, scenePos) 
  const closest = pathfinding.getClosestNode(humanPosition, ZONE, groupID);
  const handleClick = (e) => {
    target = e.point;
    const closeTarget = (pathfinding.getClosestNode(target, ZONE, nmID));
    navpath = pathfinding.findPath(closest.centroid, closeTarget.centroid, ZONE, groupID);
  };

  function move(delta) {
    if (!navpath || navpath.length <= 0) return;
  
    let targetPosition = navpath[0];
    console.log(targetPosition)
    setHumanPosition(targetPosition)
    // const distance = targetPosition.clone().sub(humanPosition);
    // // console.log(distance)
  
    // if (distance.lengthSq() > 0.05 * 0.05) {
    //   distance.normalize();
    //   // Move player to target
    //   humanPosition.add(distance.multiplyScalar(delta * SPEED));
    //   // setImpulse(pos)
    //   // setHumanPosition(pos)
    // } else {
    //   // Remove node from the path we calculated
    //   navpath.shift();
    // }
  }

  useFrame(({ clock, camera}) => {
    move(clock.getDelta())
  })


  return (
    <group {...props} dispose={null}>
      <mesh
        onClick={(e) => handleClick(e)}
        castShadow
        receiveShadow
        geometry={nodes.Navmesh.geometry}
        material={nodes.Navmesh.material}
      >
        <meshPhongMaterial color="#ff0000" opacity={0.1} transparent />
      </mesh>
    </group>
  );
};

useGLTF.preload(navmeshScene);

export default Navmesh;
